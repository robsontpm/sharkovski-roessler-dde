/* * A helper program to visualize the Roesssler attractor for the system with delay. * We use the system: * *  v'(t) = f(v(t)) + \varepsilon * f(x(t-\tau) * *  You can specify any values for the parameters, but remember that for big *  epsilon the phase portrait might be dramatically different from the original ODE! */#define DDES_ALLOW_SYSTEM#include <iostream>#include <iomanip>#include <capd/capdlib.h>#include <capd/ddes/ddeslib.h>#include <capd/ddeshelper/ddeshelperlib.h>#include <capd/ddeshelper/DDEHelperNonrigorous.hpp>#include "utils.h"using namespace std;using namespace capd;
int main(int argc, char** argv){	capd::ddeshelper::ArgumentParser parser(argc, argv);	double a = 5.7, b = 0.2, epsi = 0., tau = 0.5;	int p = 64, n = 4;	const int d = 3;	int max_steps = -50, num_iters = 40, P_iter = 1;	DVector ivp {0., 1., 0.0002};	std::string ivp_str = "{0., 1., 0.0002}";	string outpath = "nonrig-plotter-output/";	capd::ddeshelper::mkdir_p(outpath);	parser.parse("outpath=", outpath, "ouutput (sub)directory. MUST CONTAIN trailing / !");	parser.parse("p=", p, "p parameter in representation space. Number of grid points.");	parser.parse("n=", n, "p parameter in representation space. Order of representation.");	parser.parse("a=", a, "a parameter in Roessler equation");	parser.parse("b=", b, "b parameter in Roessler equation");	parser.parse("epsi=", epsi, "epsi parameter from the delayed perturbation");	parser.parse("tau=", tau, "tau parameter from the delayed perturbation");	parser.parse("max-steps=", max_steps, "number of iterates to be done. Negative value means full delays.");	parser.parse("num-iters=", num_iters, "number of iterates of P to be done");	parser.parse("p-iter=", P_iter, "P^{p_iter} image will be computed");	parser.parse("ivp=", ivp_str, "initial value. If given as 3d vector constant function of that value is used over the basic delay.");	if (parser.isHelpRequested()){		std::cout << parser.getHelp() << endl;		return 0;	}	cout << max_steps << endl;	if (max_steps < 0) max_steps = -max_steps * p;	cout << max_steps << endl;	Numerics setup({a, b, epsi, tau}, p, n, max_steps, max_steps + 1, 3 * n);	DSolution initial_segment = setup.makeSegment(n, {0, 0, 0});	if (ivp_str[0] == '{'){		std::istringstream ivp_iss(ivp_str);		ivp_iss >> ivp;		if (ivp.dimension() == d){			DSolution initial_segment = setup.makeSegment(n, ivp);		}else{			throw std::logic_error("NotImplementedYet: reading data from history.");		}	} else {		throw std::logic_error("NotImplementedYet: reading data from file.");	}	DSection section(3, 0, 0.);	auto solver = setup.makeSolver();	DPoincare P(solver, section, poincare::MinusPlus);	DSolution Px = setup.makeSegment(n);	DSolution solution = initial_segment;	for (int i = 0; i < max_steps; ++i){		solver(solution);	}	Px = solution.subcurve(solution.currentTime() - setup.grid()(p));	{	ostringstream plotpath;	string filename = "initial";	plotpath << outpath << filename;	capd::ddeshelper::plot_value(plotpath.str(), solution.pastTime(), solution.currentTime(), setup.h() / 10, solution, false);	ostringstream splotcmd;	splotcmd << "'" << filename << "ddes-plot.dat' u 3:5:7 with lines notitle";	capd::ddeshelper::splot_many(outpath, { splotcmd.str() }, false, "plot3d");	std::ostringstream cmd; cmd << "cd '" << outpath << "' && gnuplot 'plot3d.gp'";	capd::ddeshelper::runSystemCommand(cmd.str());	}	solution = Px;	double tp;	int NUM_ITERS = num_iters;	for (int i = 0; i < NUM_ITERS; ++i){		P(solution, Px, tp);		DVector pv = Px;		pv[0] = 0.0;	}	{	ostringstream plotpath;	string filename = "poincare";	plotpath << outpath << filename;	capd::ddeshelper::plot_value(plotpath.str(), solution.pastTime(), solution.currentTime(), setup.h() / 10, solution, false);	ostringstream splotcmd;	splotcmd << "'" << filename << "ddes-plot.dat' u 3:5:7 with lines notitle";	capd::ddeshelper::splot_many(outpath, { splotcmd.str() }, false, "plot3d");	std::ostringstream cmd; cmd << "cd '" << outpath << "' && gnuplot 'plot3d.gp'";	capd::ddeshelper::runSystemCommand(cmd.str());	}//	// set common parameters for both codes//	int p = 32;			// number of grid points in the basic interval. This will translate to the step size of the method := tau/p.//	int max_order = 4;  // we are doing low order method (original ODE code was order = 20, but this is the test for possible chaos in DDE-perturbed ODE, so we should keep this low (see papers and 'Long Enough Integration time')
//	interval a = interval(57) / interval(10);	// parameter a * 10
//	interval b = interval(2) / interval(10);	// parameter b * 10//	interval h = interval(1.0) / interval(p);	// the step size for both methods (CAPD ODES fixed step and capdDDEs grid size)////	// setup ODE CAPD equation//	IMap vf("par:a,b;var:x,y,z;fun:-(y+z),x+b*y,b+z*(x-a);");//	vf.setParameter("a", a);//	vf.setParameter("b", b);//	// setup ODE CAPD solver and Poincare Map//	IOdeSolver ode_solver(vf, max_order);//	ICoordinateSection ode_section(3, 0);//	IPoincareMap ode_pm(ode_solver, ode_section, poincare::MinusPlus);//	// extra setup, but similar to what we do for DDEs//	ode_pm.setMaxReturnTime(20);////	// setup the delayed equation.//	// Eq does not have fancy setParameter() functions, but id does not need ones, as it is tailored//	// for this specific Equation, not a general parser of equations as in CAPD.//	// Therefore, it suffices to pass them in the constructor.//	// The DDE-- classes declarations are in setup.h file, see how its done. You can use other names for those classes.
//	Grid grid(h);//	Eq eq(a, b);//	DDEq dde(eq);//	// setup DDE solver and Poincare map//	DDESolver dde_solver(dde, max_order);//	DDESection dde_section(3, 0);//	DDEPoincare dde_pm(dde_solver, dde_section, poincare::CrossingDirection::MinusPlus);//	// extra setup, only for DDEs//	dde_pm.setRequiredSteps(0);	// ODE should not care about this, but we must disable this manually. This is important for true DDEs, but it is controlled by the DDE code itself to be safe.//	dde_pm.setMaxSteps(1000);	// this is equivalent to ode_pm.setMaxReturnTime(), but less convenient probably////	// setting up extra output - if needed//	#ifdef EXTRA_OUTPUT//	std::ostream& out = std::cout;//	#else//	std::ostringstream devnull;//	std::ostream& out = devnull;//	#endif////	// Lambda functions that check some inequalities - they are the same as in original code//	auto mappedLeft   = [] (IVector u) { return u[1] < g_leftM; };//	auto mappedRight  = [] (IVector u) { return u[1] > g_rightN; };//	auto mappedIn     = [] (IVector u) { return u[2] > g_bottom and u[2] < g_top and u[1] > g_left and u[1]<g_right; };////	// here we will store results of the tests//	bool resultDDE = true, resultODE = true;////	// Here we check if [g_left,g_right]x[g_bottom,g_top] is mapped into itself by Poincare map.//	// From these computations we also obtain that the sets N and M are mapped across the horizontal strip.//	// This is one of the required conditions for the covering relations.//	#ifdef CHECK_TRAPPING_REGION////	int N = SLICE_N;//	std::vector<IVector> x0_slices;//	// here we will store data for nice plots//	std::vector<IVector> Px_ODE, Px_DDE;//	for (int i = 0; i < N; ++i){//		ode_pm.setStep(h.rightBound()); // we are doing low order method, without this ODE code will struggle with the step control//		ode_pm.turnOffStepControl();    // we are doing low order method, without this ODE code will struggle with the step control//		auto ddePx = checkConditionDDE(out, grid, dde_pm, g_left, g_right, i, N, mappedIn, resultDDE, 1); // the difference here is that DDEs use Grid to define solutions.//		auto odePx = checkConditionODE(out,       ode_pm, g_left, g_right, i, N, mappedIn, resultODE, 1); // ODEs code does not need grid, it can even have various time steps, see comment about step control above//		// push data for draw later//		x0_slices.push_back(odePx.first);//		Px_ODE.push_back(odePx.second);//		Px_DDE.push_back(ddePx.second);//	}//	cout << "DDES Existence of attractor: " << resultDDE << endl;//	cout << "CAPD Existence of attractor: " << resultODE << endl;////	// output data needed for nice pictures//	double box[] = {g_left, g_right, g_bottom, g_top};//	plotTrappingRegion(box, "ddeplot", x0_slices, Px_DDE);//	plotTrappingRegion(box, "odeplot", x0_slices, Px_ODE);////	#endif // CHECK_TRAPPING_REGION////	resultDDE = true; resultODE = true;//	// Remaining inequalities for the covering relations N=>N, N=>M, M=>M, M=>N.//	checkConditionDDE(out, grid,  dde_pm, g_leftM,  g_leftM,  0, 1, mappedLeft,  resultDDE);//	checkConditionODE(out,        ode_pm, g_leftM,  g_leftM,  0, 1, mappedLeft,  resultODE);//	cout << "DDES P^2( Left (M) ) < Left (M): " << resultDDE << endl;//	cout << "CAPD P^2( Left (M) ) < Left (M): " << resultODE << endl;////	resultDDE = true; resultODE = true;//	checkConditionDDE(out, grid,  dde_pm, g_rightM, g_rightM, 0, 1, mappedRight, resultDDE);//	checkConditionODE(out,        ode_pm, g_rightM, g_rightM, 0, 1, mappedRight, resultODE);//	cout << "DDES P^2( Right(M) ) > Right(N): " << resultDDE << endl;//	cout << "CAPD P^2( Right(M) ) > Right(N): " << resultODE << endl;////	resultDDE = true; resultODE = true;//	checkConditionDDE(out, grid,  dde_pm, g_leftN,  g_leftN,  0, 1, mappedRight, resultDDE);//	checkConditionODE(out,        ode_pm, g_leftN,  g_leftN,  0, 1, mappedRight, resultODE);//	cout << "DDES P^2( Left (N) ) > Right(N): " << resultDDE << endl;//	cout << "CAPD P^2( Left (N) ) > Right(N): " << resultODE << endl;////	resultDDE = true; resultODE = true;//	checkConditionDDE(out, grid,  dde_pm, g_rightN, g_rightN, 0, 1, mappedLeft,  resultDDE);//	checkConditionODE(out,        ode_pm, g_rightN, g_rightN, 0, 1, mappedLeft,  resultODE);//	cout << "DDES P^2( Right(N) ) < Left (M): " << resultDDE << endl;//	cout << "CAPD P^2( Right(N) ) < Left (M): " << resultODE << endl;	return 0;}
